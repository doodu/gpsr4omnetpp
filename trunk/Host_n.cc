//-----------------------------------------
//
// Generated by nedtool, version 3.3
// date: Fri Mar  7 23:43:52 2008
//
//-----------------------------------------


#include <math.h>
#include "omnetpp.h"

// NEDC version check
#define NEDC_VERSION 0x0303
#if (NEDC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedc: 'make clean' should help.
#endif

// Disable warnings about unused variables. For MSVC and BC only:
// GCC has no way to turn on its -Wunused option in a source file :(
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#endif
#ifdef __BORLANDC__
#  pragma warn -waus
#  pragma warn -wuse
#endif

static cModuleType *_getModuleType(const char *modname)
{
    cModuleType *modtype = findModuleType(modname);
    if (!modtype)
        throw new cRuntimeError("Module type definition %s not found (Define_Module() missing from C++ code?)", modname);
    return modtype;
}

static void _checkModuleVectorSize(int vectorsize, const char *mod)
{
    if (vectorsize<0)
        throw new cRuntimeError("Negative module vector size %s[%d]", mod, vectorsize);
}

static void _readModuleParameters(cModule *mod)
{
    int n = mod->params();
    for (int k=0; k<n; k++)
        if (mod->par(k).isInput())
            mod->par(k).read();
}

static int _checkModuleIndex(int index, int vectorsize, const char *modname)
{
    if (index<0 || index>=vectorsize)
        throw new cRuntimeError("Submodule index %s[%d] out of range, sizeof(%s) is %d", modname, index, modname, vectorsize);
    return index;
}

static cGate *_checkGate(cModule *mod, const char *gatename)
{
    cGate *g = mod->gate(gatename);
    if (!g)
        throw new cRuntimeError("%s has no gate named %s",mod->fullPath().c_str(), gatename);
    return g;
}

static cGate *_checkGate(cModule *mod, const char *gatename, int gateindex)
{
    cGate *g = mod->gate(gatename, gateindex);
    if (!g)
        throw new cRuntimeError("%s has no gate %s[%d]",mod->fullPath().c_str(), gatename, gateindex);
    return g;
}

static cGate *_getFirstUnusedParentModGate(cModule *mod, const char *gatename)
{
    int baseId = mod->findGate(gatename);
    if (baseId<0)
        throw new cRuntimeError("%s has no %s[] gate",mod->fullPath().c_str(), gatename);
    int n = mod->gate(baseId)->size();
    for (int i=0; i<n; i++)
        if (!mod->gate(baseId+i)->isConnectedInside())
            return mod->gate(baseId+i);
    throw new cRuntimeError("%s[] gates are all connected, no gate left for `++' operator",mod->fullPath().c_str(), gatename);
}

static cGate *_getFirstUnusedSubmodGate(cModule *mod, const char *gatename)
{
    int baseId = mod->findGate(gatename);
    if (baseId<0)
        throw new cRuntimeError("%s has no %s[] gate",mod->fullPath().c_str(), gatename);
    int n = mod->gate(baseId)->size();
    for (int i=0; i<n; i++)
        if (!mod->gate(baseId+i)->isConnectedOutside())
            return mod->gate(baseId+i);
    int newBaseId = mod->setGateSize(gatename,n+1);
    return mod->gate(newBaseId+n);
}

static cFunctionType *_getFunction(const char *funcname, int argcount)
{
    cFunctionType *functype = findFunction(funcname,argcount);
    if (!functype)
        throw new cRuntimeError("Function %s with %d args not found", funcname, argcount);
    return functype;
}

static cChannel *_createChannel(const char *channeltypename)
{
    cChannelType *channeltype = findChannelType(channeltypename);
    if (!channeltype)
        throw new cRuntimeError("Channel type %s not found", channeltypename);
    cChannel *channel = channeltype->create("channel");
    return channel;
}

static cChannel *_createNonTypedBasicChannel(double delay, double error, double datarate)
{
    cBasicChannel *channel = new cBasicChannel("channel");
    if (delay!=0) channel->setDelay(delay);
    if (error!=0) channel->setError(error);
    if (datarate!=0) channel->setDatarate(datarate);
    return channel;
}

static cXMLElement *_getXMLDocument(const char *fname, const char *pathexpr=NULL)
{
    cXMLElement *node = ev.getXMLDocument(fname, pathexpr);
    if (!node)
        throw new cRuntimeError(!pathexpr ? "xmldoc(\"%s\"): element not found" : "xmldoc(\"%s\", \"%s\"): element not found",fname,pathexpr);
    return node;
}

ModuleInterface(Host)
    // parameters:
    Parameter(x, ParType_Numeric ParType_Const)
    Parameter(y, ParType_Numeric ParType_Const)
    // gates:
    Gate(radioIn, GateDir_Input)
EndInterface

Register_ModuleInterface(Host);

class Host : public cCompoundModule
{
  public:
    Host() : cCompoundModule() {}
  protected:
    virtual void doBuildInside();
};

Define_Module(Host);

void Host::doBuildInside()
{
    cModule *mod = this;

    // temporary variables:
    cPar tmpval;
    const char *modtypename;

    mod->setBackgroundDisplayString("p=10,10;b=250,250,rect;o=white");

    // submodules:
    cModuleType *modtype = NULL;
    int submodindex;

    //
    // submodule 'blackboard':
    //
    int blackboard_size = 1;
    modtype = _getModuleType("Blackboard");
    cModule *blackboard_p = modtype->create("blackboard", mod);
    {
        cContextSwitcher __ctx(blackboard_p); // do the rest in this module's context

        _readModuleParameters(blackboard_p);
        blackboard_p->setDisplayString("p=200,75;b=30,25");
    }

    //
    // submodule 'mobility':
    //
    int mobility_size = 1;
    modtype = _getModuleType("ConstSpeedMobility");
    cModule *mobility_p = modtype->create("mobility", mod);
    {
        cContextSwitcher __ctx(mobility_p); // do the rest in this module's context

        // parameter assignments:
        mobility_p->par("x") = mod->par("x");
        mobility_p->par("y") = mod->par("y");

        _readModuleParameters(mobility_p);
        mobility_p->setDisplayString("p=200,150;b=30,25");
    }

    //
    // submodule 'appl':
    //
    int appl_size = 1;
    modtype = _getModuleType("BlueqApplLayer");
    cModule *appl_p = modtype->create("appl", mod);
    {
        cContextSwitcher __ctx(appl_p); // do the rest in this module's context

        // parameter assignments:
        appl_p->par("x") = mod->par("x");
        appl_p->par("y") = mod->par("y");

        _readModuleParameters(appl_p);
        appl_p->setDisplayString("p=90,50;b=100,20,rect");
    }

    //
    // submodule 'arp':
    //
    int arp_size = 1;
    modtype = _getModuleType("SimpleArp");
    cModule *arp_p = modtype->create("arp", mod);
    {
        cContextSwitcher __ctx(arp_p); // do the rest in this module's context

        _readModuleParameters(arp_p);
        arp_p->setDisplayString("p=200,225;b=30,25");
    }

    //
    // submodule 'net':
    //
    int net_size = 1;
    modtype = _getModuleType("GPSRNetwLayer");
    cModule *net_p = modtype->create("net", mod);
    {
        cContextSwitcher __ctx(net_p); // do the rest in this module's context

        // parameter assignments:
        net_p->par("x") = mod->par("x");
        net_p->par("y") = mod->par("y");

        _readModuleParameters(net_p);
        net_p->setDisplayString("p=90,100;b=100,20,rect");
    }

    //
    // submodule 'nic':
    //
    int nic_size = 1;
    modtype = _getModuleType("Nic80211");
    cModule *nic_p = modtype->create("nic", mod);
    {
        cContextSwitcher __ctx(nic_p); // do the rest in this module's context

        _readModuleParameters(nic_p);
        nic_p->setDisplayString("p=90,200;b=100,20,rect");
    }

    //
    // connections:
    //
    cGate *srcgate, *destgate;

    cChannel *channel;
    cPar *par;
    // connection
    srcgate = _checkGate(nic_p, "uppergateOut");
    destgate = _checkGate(net_p, "lowergateIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(net_p, "lowergateOut");
    destgate = _checkGate(nic_p, "uppergateIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(nic_p, "upperControlOut");
    destgate = _checkGate(net_p, "lowerControlIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(net_p, "uppergateOut");
    destgate = _checkGate(appl_p, "lowergateIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(appl_p, "lowergateOut");
    destgate = _checkGate(net_p, "uppergateIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(net_p, "upperControlOut");
    destgate = _checkGate(appl_p, "lowerControlIn");
    srcgate->connectTo(destgate);

    // connection
    srcgate = _checkGate(mod, "radioIn");
    destgate = _checkGate(nic_p, "radioIn");
    srcgate->connectTo(destgate);

    // check all gates are connected:
    mod->checkInternalConnections();


    //
    // this level is done -- recursively build submodules too
    //
    blackboard_p->buildInside();
    mobility_p->buildInside();
    appl_p->buildInside();
    arp_p->buildInside();
    net_p->buildInside();
    nic_p->buildInside();
}

